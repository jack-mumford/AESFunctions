#!/usr/bin/env python3
"""
Student Autotest for AES_Functions (single-round primitives)
- Run locally to self-check your implementation against expected results.
- This script tests the CLI contract and correctness of:
  SubBytes, InvSubBytes, ShiftRows, InvShiftRows, MixColumns, InvMixColumns, AddRoundKey.
Usage:
  make
  python3 grade_aes_functions_student.py
"""
import subprocess, sys, os, re, time

# ---------- Reference tables (S-box and Inv S-box) ----------
SBOX = [
0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
]
INV_SBOX = [
0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D
]

def xtime(x):
    x <<= 1
    if x & 0x100:
        x ^= 0x1B
    return x & 0xFF

def mul2(x): return xtime(x)
def mul3(x): return xtime(x) ^ x

def mul9(x):  return xtime(xtime(xtime(x))) ^ x
def mul11(x): return xtime(xtime(xtime(x)) ^ x) ^ x
def mul13(x): return xtime(xtime(xtime(x) ^ x)) ^ x
def mul14(x): return xtime(xtime(xtime(x) ^ x) ^ x)

def subbytes(state):  return [SBOX[b] for b in state]
def invsub(state):    return [INV_SBOX[b] for b in state]

def shiftrows(state):
    out = [0]*16
    for r in range(4):
        for c in range(4):
            src_c = (c + r) % 4
            out[c*4 + r] = state[src_c*4 + r]
    return out

def invshiftrows(state):
    out = [0]*16
    for r in range(4):
        for c in range(4):
            src_c = (c - r) % 4
            out[c*4 + r] = state[src_c*4 + r]
    return out

def mix_single_col(col):
    s0,s1,s2,s3 = col
    return [
        (mul2(s0) ^ mul3(s1) ^ s2 ^ s3) & 0xFF,
        (s0 ^ mul2(s1) ^ mul3(s2) ^ s3) & 0xFF,
        (s0 ^ s1 ^ mul2(s2) ^ mul3(s3)) & 0xFF,
        (mul3(s0) ^ s1 ^ s2 ^ mul2(s3)) & 0xFF
    ]

def invmix_single_col(col):
    s0,s1,s2,s3 = col
    return [
        (mul14(s0) ^ mul11(s1) ^ mul13(s2) ^ mul9(s3)) & 0xFF,
        (mul9(s0)  ^ mul14(s1) ^ mul11(s2) ^ mul13(s3)) & 0xFF,
        (mul13(s0) ^ mul9(s1)  ^ mul14(s2) ^ mul11(s3)) & 0xFF,
        (mul11(s0) ^ mul13(s1) ^ mul9(s2)  ^ mul14(s3)) & 0xFF
    ]

def mixcolumns(state):
    out = state[:]
    for c in range(4):
        col = [state[c*4 + r] for r in range(4)]
        m = mix_single_col(col)
        for r in range(4):
            out[c*4 + r] = m[r]
    return out

def invmixcolumns(state):
    out = state[:]
    for c in range(4):
        col = [state[c*4 + r] for r in range(4)]
        m = invmix_single_col(col)
        for r in range(4):
            out[c*4 + r] = m[r]
    return out

def addroundkey(state,key):
    return [ (state[i]^key[i]) & 0xFF for i in range(16) ]

HEX_RE = re.compile(r'^[0-9a-fA-F]+$')

def parse_hex_to_16(h):
    h = h.strip()
    assert h == "" or HEX_RE.match(h)
    if len(h) % 2 != 0:
        raise ValueError("odd hex length")
    b = [int(h[i:i+2],16) for i in range(0,len(h),2)]
    if len(b) > 16:
        b = b[:16]
    while len(b) < 16:
        b.append(0)
    return b

def hex32(b):
    return ''.join(f'{x:02X}' for x in b)

def spawn(exe):
    return subprocess.Popen([exe], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)

def send(p, line):
    p.stdin.write(line + "\n")
    p.stdin.flush()

def read_until_state(p, timeout=3.0):
    out = ""
    deadline = time.time() + timeout
    last_state = None
    while time.time() < deadline:
        line = p.stdout.readline()
        if not line:
            time.sleep(0.01); continue
        out += line
        m = re.search(r'STATE=([0-9A-F]{32})', line)
        if m:
            return m.group(1), out
    raise RuntimeError("Timed out waiting for STATE=...; output so far:\n" + out)

def build_case(pt_hex, sequence):
    state = parse_hex_to_16(pt_hex)
    steps = []
    for op in sequence:
        if op[0] == 'SUB':
            state = subbytes(state); steps.append(('SUB', state[:]))
        elif op[0] == 'INV_SUB':
            state = invsub(state); steps.append(('INV_SUB', state[:]))
        elif op[0] == 'SHIFT':
            state = shiftrows(state); steps.append(('SHIFT', state[:]))
        elif op[0] == 'INV_SHIFT':
            state = invshiftrows(state); steps.append(('INV_SHIFT', state[:]))
        elif op[0] == 'MIX':
            state = mixcolumns(state); steps.append(('MIX', state[:]))
        elif op[0] == 'INV_MIX':
            state = invmixcolumns(state); steps.append(('INV_MIX', state[:]))
        elif op[0] == 'XOR':
            key = parse_hex_to_16(op[1])
            state = addroundkey(state, key); steps.append((f'XOR {hex32(key)}', state[:]))
        else:
            raise ValueError("Unknown op " + op[0])
    return {
        'plaintext': pt_hex,
        'expected_after_load': parse_hex_to_16(pt_hex),
        'steps': steps
    }

def run_case(exe, case):
    p = spawn(exe)
    # Initial prompt expects plaintext
    send(p, case['plaintext'])
    got, out = read_until_state(p)
    exp = hex32(case['expected_after_load'])
    if got != exp:
        p.kill(); raise AssertionError(f"Initial STATE mismatch.\nExpected {exp}\nGot      {got}\nOutput:\n{out}")
    for cmd, exp_state in case['steps']:
        send(p, cmd)
        got, out = read_until_state(p)
        exp = hex32(exp_state)
        if got != exp:
            p.kill(); raise AssertionError(f"After '{cmd}' mismatch.\nExpected {exp}\nGot      {got}\nOutput:\n{out}")
    send(p, "EXIT")
    try:
        p.wait(timeout=1.0)
    except subprocess.TimeoutExpired:
        p.kill()

def main():
    exe = "./AES_Functions"
    if not os.path.exists(exe):
        print("ERROR: ./AES_Functions not found. Run 'make' first.", file=sys.stderr)
        sys.exit(2)

    # --- Minimal student-visible tests ---
    TESTS = [
        # NIST-like plaintext
        build_case("00112233445566778899aabbccddeeff",
                   [('SUB',), ('INV_SUB',),
                    ('SHIFT',), ('INV_SHIFT',),
                    ('MIX',), ('INV_MIX',),
                    ('XOR','000102030405060708090A0B0C0D0E0F')]),

        # Short input (pads with zeros)
        build_case("DEADBEEF", [('SUB',), ('SHIFT',), ('INV_SHIFT',), ('INV_SUB',)]),
    ]

    for i, t in enumerate(TESTS, 1):
        try:
            run_case(exe, t)
            print(f"[OK] Test {i}")
        except Exception as e:
            print(f"[FAIL] Test {i}: {e}")
            sys.exit(1)

    print("All public tests passed. (Hidden tests may still be used during grading.)")

if __name__ == "__main__":
    main()
